{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Strawberry integration with Django. makes it easier to build better web apps more quickly and with less code. Supported features: \u00b6 GraphQL type generation from models Filtering, pagination and ordering Basic create, retrieve, update and delete (CRUD) types and mutations Basic Django auth support, current user query, login and logout mutations Django sync and async views Unit test integration Installation \u00b6 pip install strawberry - graphql - django Basic Usage \u00b6 # models.py from django.db import models class Fruit ( models . Model ): \"\"\"A tasty treat\"\"\" name = models . CharField ( max_length = 20 ) color = models . ForeignKey ( 'Color' , blank = True , null = True , related_name = 'fruits' , on_delete = models . CASCADE ) class Color ( models . Model ): name = models . CharField ( max_length = 20 , help_text = \"field description\" , ) # types.py import strawberry from strawberry import auto from typing import List from . import models @strawberry . django . type ( models . Fruit ) class Fruit : id : auto name : auto color : 'Color' @strawberry . django . type ( models . Color ) class Color : id : auto name : auto fruits : List [ Fruit ] # schema.py import strawberry from typing import List from .types import Fruit @strawberry . type class Query : fruits : List [ Fruit ] = strawberry . django . field () schema = strawberry . Schema ( query = Query ) # settings.py STRAWBERRY_DJANGO = { \"FIELD_DESCRIPTION_FROM_HELP_TEXT\" : True , \"TYPE_DESCRIPTION_FROM_MODEL_DOCSTRING\" : True , } Code above generates following schema. \"\"\" A tasty treat \"\"\" type Fruit { id: ID! name: String! color: Color } type Color { id: ID! \"\"\" field description \"\"\" name: String! fruits: [Fruit!] } type Query { fruits: [Fruit!]! } # urls.py from django.urls import include , path from strawberry.django.views import AsyncGraphQLView from .schema import schema urlpatterns = [ path ( 'graphql' , AsyncGraphQLView . as_view ( schema = schema )), ]","title":"Strawberry GraphQL Django"},{"location":"#supported-features","text":"GraphQL type generation from models Filtering, pagination and ordering Basic create, retrieve, update and delete (CRUD) types and mutations Basic Django auth support, current user query, login and logout mutations Django sync and async views Unit test integration","title":"Supported features:"},{"location":"#installation","text":"pip install strawberry - graphql - django","title":"Installation"},{"location":"#basic-usage","text":"# models.py from django.db import models class Fruit ( models . Model ): \"\"\"A tasty treat\"\"\" name = models . CharField ( max_length = 20 ) color = models . ForeignKey ( 'Color' , blank = True , null = True , related_name = 'fruits' , on_delete = models . CASCADE ) class Color ( models . Model ): name = models . CharField ( max_length = 20 , help_text = \"field description\" , ) # types.py import strawberry from strawberry import auto from typing import List from . import models @strawberry . django . type ( models . Fruit ) class Fruit : id : auto name : auto color : 'Color' @strawberry . django . type ( models . Color ) class Color : id : auto name : auto fruits : List [ Fruit ] # schema.py import strawberry from typing import List from .types import Fruit @strawberry . type class Query : fruits : List [ Fruit ] = strawberry . django . field () schema = strawberry . Schema ( query = Query ) # settings.py STRAWBERRY_DJANGO = { \"FIELD_DESCRIPTION_FROM_HELP_TEXT\" : True , \"TYPE_DESCRIPTION_FROM_MODEL_DOCSTRING\" : True , } Code above generates following schema. \"\"\" A tasty treat \"\"\" type Fruit { id: ID! name: String! color: Color } type Color { id: ID! \"\"\" field description \"\"\" name: String! fruits: [Fruit!] } type Query { fruits: [Fruit!]! } # urls.py from django.urls import include , path from strawberry.django.views import AsyncGraphQLView from .schema import schema urlpatterns = [ path ( 'graphql' , AsyncGraphQLView . as_view ( schema = schema )), ]","title":"Basic Usage"},{"location":"community-projects/","text":"Project Description Strawberry-Django-plus Additional features that are out of this project scope. Strawberry-Django-JWT JWT implementation with Strawberry and Django. Strawberry-Django-Auth Authentication System for Django using Strawberry.","title":"Community projects"},{"location":"contributing/","text":"We use poetry to manage dependencies, to get started follow these steps: git clone https://github.com/strawberry-graphql/strawberry-graphql-django.git cd strawberry-graphql-django poetry install poetry run pytest This will install all the dependencies (including dev ones) and run the tests. Pre commit \u00b6 We have a configuration for pre-commit , to add the hook run the following command: pre-commit install Docs setup and local server: \u00b6 We use Material for MkDocs, you can read the documentation here make serve-docs","title":"Contributing"},{"location":"contributing/#pre-commit","text":"We have a configuration for pre-commit , to add the hook run the following command: pre-commit install","title":"Pre commit"},{"location":"contributing/#docs-setup-and-local-server","text":"We use Material for MkDocs, you can read the documentation here make serve-docs","title":"Docs setup and local server:"},{"location":"faq/","text":"Frequently Asked Questions (FAQ) \u00b6 How to access Django request object in resolvers? \u00b6 The request object is accessible via the info.context.request object. def resolver ( root , info : Info ): request = info . context . request How to access the current user object in resolvers? \u00b6 The current user object is accessible via the info.context.request.user object. def resolver ( root , info : Info ): current_user = info . context . request . user Autocompletion with editors \u00b6 Some editors like VSCode may not be able to resolve symbols and types without explicit strawberry.django import. Adding following line to code fixes that problem. import strawberry.django Example project? \u00b6 See complete Django project from github repository folder examples/django .","title":"FAQ"},{"location":"faq/#frequently-asked-questions-faq","text":"","title":"Frequently Asked Questions (FAQ)"},{"location":"faq/#how-to-access-django-request-object-in-resolvers","text":"The request object is accessible via the info.context.request object. def resolver ( root , info : Info ): request = info . context . request","title":"How to access Django request object in resolvers?"},{"location":"faq/#how-to-access-the-current-user-object-in-resolvers","text":"The current user object is accessible via the info.context.request.user object. def resolver ( root , info : Info ): current_user = info . context . request . user","title":"How to access the current user object in resolvers?"},{"location":"faq/#autocompletion-with-editors","text":"Some editors like VSCode may not be able to resolve symbols and types without explicit strawberry.django import. Adding following line to code fixes that problem. import strawberry.django","title":"Autocompletion with editors"},{"location":"faq/#example-project","text":"See complete Django project from github repository folder examples/django .","title":"Example project?"},{"location":"guides/quick-start/","text":"Strawberry GraphQL Django extension \u00b6 This library provides a toolset for GraphQL schema generation from Django models. Installing the package \u00b6 pip install strawberry_graphql_django Sample project \u00b6 Your boss asks you for a Django model called Fruit , which has two attributes, name and color. # models.py from django.db import models class Fruit ( models . Model ): name = models . CharField ( max_length = 20 ) color = models . CharField ( max_length = 20 ) Soon after that, your boss asks you to implement an API for that model so that everyone can access our great fruit database from all over the world. The Fruit model has name and color attributes and we want to publish both of them. The GraphQL output type for our model is generated by using the strawberry_django.type decorator. Both fields are char fields so we will need to use the built-in Python str type in our API. # types.py import strawberry_django from . import models @strawberry_django . type ( models . Fruit ) class Fruit : name : str color : str The last step is to generate the Query type and the Schema , which we can do using the core package strawberry . # schema.py import strawberry from typing import List from .types import Fruit @strawberry . type class Query : fruits : List [ Fruit ] = strawberry . django . field () schema = strawberry . Schema ( query = Query ) Finally we add a AsyncGraphQLView view to our list of urls so that we can start making our first queries. # urls.py from django.urls import include , path from strawberry.django.views import AsyncGraphQLView from .schema import schema urlpatterns = [ path ( 'graphql' , AsyncGraphQLView . as_view ( schema = schema )), ] After that, once the development server is running, you can read your fruits from the database through a GraphQL request. query { fruits { name color } } # -> fruits: [{ name: \"strawberry\", color: \"red\" }] Model Relations \u00b6 Your boss wants the models to be more scalable. In particular, they think encoding color as a string is too limiting. Let's create another model called Color and add a foreign key relation between the Fruit and Color models. # models.py from django.db import models class Fruit ( models . Model ): name = models . CharField ( max_length = 20 ) color = models . ForeignKey ( 'Color' , related_name = 'fruits' , on_delete = models . CASCADE ) class Color ( models . Model ): name = models . CharField ( max_length = 20 ) We also need to add a GraphQL Type for Color and modify the existing Fruit type to reflect our changes. The auto field type is used for automatic type resolution. strawberry_django goes through all fields and resolves field types. It also generates resolvers for relation fields for you. # types.py import strawberry_django from strawberry import auto from typing import List from . import models @strawberry_django . type ( models . Fruit ) class Fruit : id : auto name : auto color : 'Color' @strawberry_django . type ( models . Color ) class Color : id : auto name : auto fruits : List [ Fruit ] This generates the following schema: type Color { id: ID! name: String! fruits: [Fruit!] } type Fruit { id: ID! name: String! color: Color! } type Query { fruits: [Fruit!]! } Now you can start making queries and request all fruits and their colors from the database. query { fruits { name color { name } } } # -> fruits: [ # { name: \"strawberry\", color: { name: \"red\" } }, # { name: \"raspberry\", color: { name: \"yellow\" } } # ]","title":"Query optimizer"},{"location":"guides/quick-start/#strawberry-graphql-django-extension","text":"This library provides a toolset for GraphQL schema generation from Django models.","title":"Strawberry GraphQL Django extension"},{"location":"guides/quick-start/#installing-the-package","text":"pip install strawberry_graphql_django","title":"Installing the package"},{"location":"guides/quick-start/#sample-project","text":"Your boss asks you for a Django model called Fruit , which has two attributes, name and color. # models.py from django.db import models class Fruit ( models . Model ): name = models . CharField ( max_length = 20 ) color = models . CharField ( max_length = 20 ) Soon after that, your boss asks you to implement an API for that model so that everyone can access our great fruit database from all over the world. The Fruit model has name and color attributes and we want to publish both of them. The GraphQL output type for our model is generated by using the strawberry_django.type decorator. Both fields are char fields so we will need to use the built-in Python str type in our API. # types.py import strawberry_django from . import models @strawberry_django . type ( models . Fruit ) class Fruit : name : str color : str The last step is to generate the Query type and the Schema , which we can do using the core package strawberry . # schema.py import strawberry from typing import List from .types import Fruit @strawberry . type class Query : fruits : List [ Fruit ] = strawberry . django . field () schema = strawberry . Schema ( query = Query ) Finally we add a AsyncGraphQLView view to our list of urls so that we can start making our first queries. # urls.py from django.urls import include , path from strawberry.django.views import AsyncGraphQLView from .schema import schema urlpatterns = [ path ( 'graphql' , AsyncGraphQLView . as_view ( schema = schema )), ] After that, once the development server is running, you can read your fruits from the database through a GraphQL request. query { fruits { name color } } # -> fruits: [{ name: \"strawberry\", color: \"red\" }]","title":"Sample project"},{"location":"guides/quick-start/#model-relations","text":"Your boss wants the models to be more scalable. In particular, they think encoding color as a string is too limiting. Let's create another model called Color and add a foreign key relation between the Fruit and Color models. # models.py from django.db import models class Fruit ( models . Model ): name = models . CharField ( max_length = 20 ) color = models . ForeignKey ( 'Color' , related_name = 'fruits' , on_delete = models . CASCADE ) class Color ( models . Model ): name = models . CharField ( max_length = 20 ) We also need to add a GraphQL Type for Color and modify the existing Fruit type to reflect our changes. The auto field type is used for automatic type resolution. strawberry_django goes through all fields and resolves field types. It also generates resolvers for relation fields for you. # types.py import strawberry_django from strawberry import auto from typing import List from . import models @strawberry_django . type ( models . Fruit ) class Fruit : id : auto name : auto color : 'Color' @strawberry_django . type ( models . Color ) class Color : id : auto name : auto fruits : List [ Fruit ] This generates the following schema: type Color { id: ID! name: String! fruits: [Fruit!] } type Fruit { id: ID! name: String! color: Color! } type Query { fruits: [Fruit!]! } Now you can start making queries and request all fruits and their colors from the database. query { fruits { name color { name } } } # -> fruits: [ # { name: \"strawberry\", color: { name: \"red\" } }, # { name: \"raspberry\", color: { name: \"yellow\" } } # ]","title":"Model Relations"},{"location":"guides/relationships/","text":"(TBD) \u00b6","title":"Realtionships"},{"location":"guides/relationships/#tbd","text":"","title":"(TBD)"},{"location":"guides/unit-testing/","text":"(TBD) \u00b6","title":"UnitTesting"},{"location":"guides/unit-testing/#tbd","text":"","title":"(TBD)"},{"location":"references/authentication/","text":"Authentication \u00b6 strawberry_django provides mutations to get authentication going right away. The auth.register mutation performs password validation using Django's validate_password method. # types.py import strawberry from strawberry import auto from django.contrib.auth import get_user_model @strawberry . django . type ( get_user_model ()) class User : username : auto email : auto @strawberry . django . input ( get_user_model ()) class UserInput : username : auto password : auto # schema.py from strawberry.django import auth from .types import User , UserInput @strawberry . type class Query : me : User = auth . current_user () @strawberry . type class Mutation : login : User = auth . login () logout = auth . logout () register : User = auth . register ( UserInput )","title":"Authentication"},{"location":"references/authentication/#authentication","text":"strawberry_django provides mutations to get authentication going right away. The auth.register mutation performs password validation using Django's validate_password method. # types.py import strawberry from strawberry import auto from django.contrib.auth import get_user_model @strawberry . django . type ( get_user_model ()) class User : username : auto email : auto @strawberry . django . input ( get_user_model ()) class UserInput : username : auto password : auto # schema.py from strawberry.django import auth from .types import User , UserInput @strawberry . type class Query : me : User = auth . current_user () @strawberry . type class Mutation : login : User = auth . login () logout = auth . logout () register : User = auth . register ( UserInput )","title":"Authentication"},{"location":"references/fields/","text":"Fields \u00b6 Fields can be defined manually or auto type can be used for automatic type resolution. All basic field types and relation fields are supported out of the box. If you use a library that defines a custom field you will need to define an equivalent type such as str , float , bool , int or id . # types.py import strawberry from strawberry import auto @strawberry . django . type ( models . Fruit ) class Fruit : id : auto name : auto # equivalent type, inferred by `strawberry` @strawberry . django . type ( models . Fruit ) class Fruit : id : strawberry . ID name : str Relationships \u00b6 All one-to-one, one-to-many, many-to-one and many-to-many relationship types are supported, and the many-to-many relation is described using the typing.List annotation. The default resolver of strawberry.django.fields() resolves the relationship based on given type information. # types.py from typing import List @strawberry . django . type ( models . Fruit ) class Fruit : id : auto name : auto color : 'Color' @strawberry . django . type ( models . Color ) class Color : id : auto name : auto fruits : List [ Fruit ] Field customization \u00b6 All Django types are encoded using the strawberry.django.field() field type by default. Fields can be customized with various parameters. # types.py @strawberry . django . type ( models . Color ) class Color : another_name : auto = strawberry . django . field ( field_name = 'name' ) internal_name : auto = strawberry . django . field ( name = 'fruits' , field_name = 'fruit_set' , filters = FruitFilter , order = FruitOrder , pagination = True , description = \"A list of fruits with this color\" ) Overriding the field class (advanced) \u00b6 If in your project, you want to change/add some of the standard strawberry.django.field() behaviour, it is possible to use your own custom field class when decorating a strawberry.django.type with the field_cls argument, e.g. class CustomStrawberryDjangoField ( StrawberryDjangoField ): \"\"\"Your custom behaviour goes here.\"\"\" @strawberry_django . type ( User , field_cls = CustomStrawberryDjangoField ) class UserType : # Each of these fields will be an instance of `CustomStrawberryDjangoField`. id : int name : auto @strawberry . type class UserQuery : # You can directly create your custom field class on a plain strawberry type user : UserType = CustomStrawberryDjangoField () In this example, each of the fields of the UserType will be automatically created by CustomStrawberryDjangoField , which may implement anything from custom pagination of relationships to altering the field permissions.","title":"Fields"},{"location":"references/fields/#fields","text":"Fields can be defined manually or auto type can be used for automatic type resolution. All basic field types and relation fields are supported out of the box. If you use a library that defines a custom field you will need to define an equivalent type such as str , float , bool , int or id . # types.py import strawberry from strawberry import auto @strawberry . django . type ( models . Fruit ) class Fruit : id : auto name : auto # equivalent type, inferred by `strawberry` @strawberry . django . type ( models . Fruit ) class Fruit : id : strawberry . ID name : str","title":"Fields"},{"location":"references/fields/#relationships","text":"All one-to-one, one-to-many, many-to-one and many-to-many relationship types are supported, and the many-to-many relation is described using the typing.List annotation. The default resolver of strawberry.django.fields() resolves the relationship based on given type information. # types.py from typing import List @strawberry . django . type ( models . Fruit ) class Fruit : id : auto name : auto color : 'Color' @strawberry . django . type ( models . Color ) class Color : id : auto name : auto fruits : List [ Fruit ]","title":"Relationships"},{"location":"references/fields/#field-customization","text":"All Django types are encoded using the strawberry.django.field() field type by default. Fields can be customized with various parameters. # types.py @strawberry . django . type ( models . Color ) class Color : another_name : auto = strawberry . django . field ( field_name = 'name' ) internal_name : auto = strawberry . django . field ( name = 'fruits' , field_name = 'fruit_set' , filters = FruitFilter , order = FruitOrder , pagination = True , description = \"A list of fruits with this color\" )","title":"Field customization"},{"location":"references/fields/#overriding-the-field-class-advanced","text":"If in your project, you want to change/add some of the standard strawberry.django.field() behaviour, it is possible to use your own custom field class when decorating a strawberry.django.type with the field_cls argument, e.g. class CustomStrawberryDjangoField ( StrawberryDjangoField ): \"\"\"Your custom behaviour goes here.\"\"\" @strawberry_django . type ( User , field_cls = CustomStrawberryDjangoField ) class UserType : # Each of these fields will be an instance of `CustomStrawberryDjangoField`. id : int name : auto @strawberry . type class UserQuery : # You can directly create your custom field class on a plain strawberry type user : UserType = CustomStrawberryDjangoField () In this example, each of the fields of the UserType will be automatically created by CustomStrawberryDjangoField , which may implement anything from custom pagination of relationships to altering the field permissions.","title":"Overriding the field class (advanced)"},{"location":"references/filters/","text":"Filtering \u00b6 import strawberry from strawberry import auto @strawberry . django . filters . filter ( models . Fruit ) class FruitFilter : id : auto name : auto @strawberry . django . type ( models . Fruit , filters = FruitFilter ) class Fruit : ... The code above generates the following schema: input FruitFilter { id: ID name: String } Lookups \u00b6 Lookups can be added to all fields with lookups=True . @strawberry . django . filters . filter ( models . Fruit , lookups = True ) class FruitFilter : id : auto name : auto Single-field lookup can be annotated with the FilterLookup generic type. from strawberry.django.filters import FilterLookup @strawberry . django . filters . filter ( models . Fruit ) class FruitFilter : name : FilterLookup [ str ] Filtering over relationships \u00b6 @strawberry . django . filters . filter ( models . Fruit ) class FruitFilter : id : auto name : auto colors : 'ColorFilter' @strawberry . django . filters . filter ( models . Color ) class ColorFilter : id : auto name : auto fruits : FruitFilter Custom filters and overriding default filtering methods \u00b6 You can define custom filter methods and override default filter methods by defining your own resolver. @strawberry . django . filters . filter ( models . Fruit ) class FruitFilter : is_banana : bool | None def filter_is_banana ( self , queryset ): if self . is_banana is None : return queryset if self . is_banana : return queryset . filter ( name = 'banana' ) return queryset . exclude ( name = 'banana' ) Overriding the default filter method \u00b6 For overriding the default filter logic you can provide the filter method. Note that this completely disables the default filtering, which means your custom method is responsible for handling all filter-related operations. @strawberry . django . filters . filter ( models . Fruit ) class FruitFilter : is_apple : bool def filter ( self , queryset ): if self . is_apple : return queryset . filter ( name = 'apple' ) return queryset . exclude ( name = 'apple' ) Adding filters to types \u00b6 All fields and mutations inherit filters from the underlying type by default. @strawberry . django . type ( models . Fruit , filters = FruitFilter ) class Fruit : ... Adding filters directly into a field \u00b6 Filters added into a field override the default filters of this type. @strawberry . type class Query : fruit : Fruit = strawberry . django . field ( filters = FruitFilter )","title":"Filters"},{"location":"references/filters/#filtering","text":"import strawberry from strawberry import auto @strawberry . django . filters . filter ( models . Fruit ) class FruitFilter : id : auto name : auto @strawberry . django . type ( models . Fruit , filters = FruitFilter ) class Fruit : ... The code above generates the following schema: input FruitFilter { id: ID name: String }","title":"Filtering"},{"location":"references/filters/#lookups","text":"Lookups can be added to all fields with lookups=True . @strawberry . django . filters . filter ( models . Fruit , lookups = True ) class FruitFilter : id : auto name : auto Single-field lookup can be annotated with the FilterLookup generic type. from strawberry.django.filters import FilterLookup @strawberry . django . filters . filter ( models . Fruit ) class FruitFilter : name : FilterLookup [ str ]","title":"Lookups"},{"location":"references/filters/#filtering-over-relationships","text":"@strawberry . django . filters . filter ( models . Fruit ) class FruitFilter : id : auto name : auto colors : 'ColorFilter' @strawberry . django . filters . filter ( models . Color ) class ColorFilter : id : auto name : auto fruits : FruitFilter","title":"Filtering over relationships"},{"location":"references/filters/#custom-filters-and-overriding-default-filtering-methods","text":"You can define custom filter methods and override default filter methods by defining your own resolver. @strawberry . django . filters . filter ( models . Fruit ) class FruitFilter : is_banana : bool | None def filter_is_banana ( self , queryset ): if self . is_banana is None : return queryset if self . is_banana : return queryset . filter ( name = 'banana' ) return queryset . exclude ( name = 'banana' )","title":"Custom filters and overriding default filtering methods"},{"location":"references/filters/#overriding-the-default-filter-method","text":"For overriding the default filter logic you can provide the filter method. Note that this completely disables the default filtering, which means your custom method is responsible for handling all filter-related operations. @strawberry . django . filters . filter ( models . Fruit ) class FruitFilter : is_apple : bool def filter ( self , queryset ): if self . is_apple : return queryset . filter ( name = 'apple' ) return queryset . exclude ( name = 'apple' )","title":"Overriding the default filter method"},{"location":"references/filters/#adding-filters-to-types","text":"All fields and mutations inherit filters from the underlying type by default. @strawberry . django . type ( models . Fruit , filters = FruitFilter ) class Fruit : ...","title":"Adding filters to types"},{"location":"references/filters/#adding-filters-directly-into-a-field","text":"Filters added into a field override the default filters of this type. @strawberry . type class Query : fruit : Fruit = strawberry . django . field ( filters = FruitFilter )","title":"Adding filters directly into a field"},{"location":"references/mutations/","text":"Mutations \u00b6 # schema.py from strawberry_django import mutations @strawberry . type class Mutation : createFruit : Fruit = mutations . create ( FruitInput ) createFruits : List [ Fruit ] = mutations . create ( FruitInput ) updateFruits : List [ Fruit ] = mutations . update ( FruitPartialInput ) deleteFruits : List [ Fruit ] = mutations . delete () schema = strawberry . Schema ( mutation = Mutation ) Filtering \u00b6 Filters can be added to update and delete mutations. More information in the filtering section. # schema.py from strawberry_django import mutations @strawberry . type class Mutation : updateFruits : List [ Fruit ] = mutations . update ( FruitPartialInput , filters = FruitFilter ) deleteFruits : List [ Fruit ] = mutations . delete ( filters = FruitFilter ) schema = strawberry . Schema ( mutation = Mutation )","title":"Mutations"},{"location":"references/mutations/#mutations","text":"# schema.py from strawberry_django import mutations @strawberry . type class Mutation : createFruit : Fruit = mutations . create ( FruitInput ) createFruits : List [ Fruit ] = mutations . create ( FruitInput ) updateFruits : List [ Fruit ] = mutations . update ( FruitPartialInput ) deleteFruits : List [ Fruit ] = mutations . delete () schema = strawberry . Schema ( mutation = Mutation )","title":"Mutations"},{"location":"references/mutations/#filtering","text":"Filters can be added to update and delete mutations. More information in the filtering section. # schema.py from strawberry_django import mutations @strawberry . type class Mutation : updateFruits : List [ Fruit ] = mutations . update ( FruitPartialInput , filters = FruitFilter ) deleteFruits : List [ Fruit ] = mutations . delete ( filters = FruitFilter ) schema = strawberry . Schema ( mutation = Mutation )","title":"Filtering"},{"location":"references/ordering/","text":"Ordering \u00b6 NOTE: this API may still change @strawberry . django . ordering . order ( models . Color ) class ColorOrder : name : auto @strawberry . django . ordering . order ( models . Fruit ) class FruitOrder : name : auto color : ColorOrder The code above generates the following schema: enum Ordering { ASC DESC } input ColorOrder { name: Ordering } input FruitOrder { name: Ordering color: ColorOrder } Adding orderings to types \u00b6 All fields and mutations inherit orderings from the underlying type by default. @strawberry . django . type ( models . Fruit , order = FruitOrder ) class Fruit : ... Adding orderings directly into a field \u00b6 Orderings added into a field override the default filters of this type. @strawberry . type class Query : fruit : Fruit = strawberry . django . field ( order = FruitOrder )","title":"Ordering"},{"location":"references/ordering/#ordering","text":"NOTE: this API may still change @strawberry . django . ordering . order ( models . Color ) class ColorOrder : name : auto @strawberry . django . ordering . order ( models . Fruit ) class FruitOrder : name : auto color : ColorOrder The code above generates the following schema: enum Ordering { ASC DESC } input ColorOrder { name: Ordering } input FruitOrder { name: Ordering color: ColorOrder }","title":"Ordering"},{"location":"references/ordering/#adding-orderings-to-types","text":"All fields and mutations inherit orderings from the underlying type by default. @strawberry . django . type ( models . Fruit , order = FruitOrder ) class Fruit : ...","title":"Adding orderings to types"},{"location":"references/ordering/#adding-orderings-directly-into-a-field","text":"Orderings added into a field override the default filters of this type. @strawberry . type class Query : fruit : Fruit = strawberry . django . field ( order = FruitOrder )","title":"Adding orderings directly into a field"},{"location":"references/pagination/","text":"Pagination \u00b6 Currently only offset and limit type of pagination are supported. @strawberry . django . type ( models . Fruit , pagination = True ) class Fruit : name : auto","title":"Pagination"},{"location":"references/pagination/#pagination","text":"Currently only offset and limit type of pagination are supported. @strawberry . django . type ( models . Fruit , pagination = True ) class Fruit : name : auto","title":"Pagination"},{"location":"references/permissions/","text":"(TBD, not supported yet) \u00b6","title":"Permissions"},{"location":"references/permissions/#tbd-not-supported-yet","text":"","title":"(TBD, not supported yet)"},{"location":"references/queries/","text":"(TBD) \u00b6","title":"Queries"},{"location":"references/queries/#tbd","text":"","title":"(TBD)"},{"location":"references/resolvers/","text":"Resolvers \u00b6 Basic resolvers are generated automatically once the types are declared. However it is possible to override them with custom resolvers. Sync resolvers \u00b6 # types.py from strawberry import auto from typing import List from . import models @strawberry . django . type ( models . Color ) class Color : id : auto name : auto @strawberry_django . field def fruits ( self ) -> List [ Fruit ]: return self . fruits . objects . filter ( ... ) Async resolvers \u00b6 # types.py from strawberry import auto from typing import List from . import models from asgiref.sync import sync_to_async @strawberry . django . type ( models . Color ) class Color : id : auto name : auto @strawberry . django . field async def fruits ( self ) -> List [ Fruit ]: @sync_to_async def query (): return list ( self . fruits . objects . filter ( ... )) return query () Issues with Resolvers \u00b6 It is important to note that overriding resolvers also removes default capabilities (e.g. Pagination , Filter ). On your root Query , you can use a custom get_queryset to achieve similar results, but note that it will affect all root queries for that type. For example, if we wanted a query for berries and one for non-berry fruits, we could do the following: # types.py import strawberry import strawberry_django from strawberry.django import auto from typing import List from . import models @strawberry . django . type ( models . Fruit , is_interface = True ) class Fruit : id : auto name : auto @strawberry . django . type ( models . Fruit ) class Berry ( Fruit ): def get_queryset ( self , queryset , info ): return queryset . filter ( name__contains = \"berry\" ) @strawberry . django . type ( models . Fruit ) class NonBerry ( Fruit ): def get_queryset ( self , queryset , info ): return queryset . exclude ( name__contains = \"berry\" ) @strawberry . type class Query : berries : List [ Berry ] non_berries : List [ NonBerry ]","title":"Resolvers"},{"location":"references/resolvers/#resolvers","text":"Basic resolvers are generated automatically once the types are declared. However it is possible to override them with custom resolvers.","title":"Resolvers"},{"location":"references/resolvers/#sync-resolvers","text":"# types.py from strawberry import auto from typing import List from . import models @strawberry . django . type ( models . Color ) class Color : id : auto name : auto @strawberry_django . field def fruits ( self ) -> List [ Fruit ]: return self . fruits . objects . filter ( ... )","title":"Sync resolvers"},{"location":"references/resolvers/#async-resolvers","text":"# types.py from strawberry import auto from typing import List from . import models from asgiref.sync import sync_to_async @strawberry . django . type ( models . Color ) class Color : id : auto name : auto @strawberry . django . field async def fruits ( self ) -> List [ Fruit ]: @sync_to_async def query (): return list ( self . fruits . objects . filter ( ... )) return query ()","title":"Async resolvers"},{"location":"references/resolvers/#issues-with-resolvers","text":"It is important to note that overriding resolvers also removes default capabilities (e.g. Pagination , Filter ). On your root Query , you can use a custom get_queryset to achieve similar results, but note that it will affect all root queries for that type. For example, if we wanted a query for berries and one for non-berry fruits, we could do the following: # types.py import strawberry import strawberry_django from strawberry.django import auto from typing import List from . import models @strawberry . django . type ( models . Fruit , is_interface = True ) class Fruit : id : auto name : auto @strawberry . django . type ( models . Fruit ) class Berry ( Fruit ): def get_queryset ( self , queryset , info ): return queryset . filter ( name__contains = \"berry\" ) @strawberry . django . type ( models . Fruit ) class NonBerry ( Fruit ): def get_queryset ( self , queryset , info ): return queryset . exclude ( name__contains = \"berry\" ) @strawberry . type class Query : berries : List [ Berry ] non_berries : List [ NonBerry ]","title":"Issues with Resolvers"},{"location":"references/settings/","text":"Django Settings \u00b6 Certain features of this library are configured using custom Django settings . STRAWBERRY_DJANGO \u00b6 A dictionary with the following optional keys: FIELD_DESCRIPTION_FROM_HELP_TEXT (Default: False ) If True, GraphQL field's description will be fetched from the corresponding Django model field's help_text attribute . If a description is provided using field customization , that description will be used instead. TYPE_DESCRIPTION_FROM_MODEL_DOCSTRING (Default: False ) If True, GraphQL type descriptions will be fetched from the corresponding Django model's docstring . If a description is provided using the strawberry_django.type decorator , that description will be used instead. These features can be enabled by adding this code to your settings.py file. STRAWBERRY_DJANGO = { \"FIELD_DESCRIPTION_FROM_HELP_TEXT\" : True , \"TYPE_DESCRIPTION_FROM_MODEL_DOCSTRING\" : True , }","title":"Settings"},{"location":"references/settings/#django-settings","text":"Certain features of this library are configured using custom Django settings .","title":"Django Settings"},{"location":"references/settings/#strawberry_django","text":"A dictionary with the following optional keys: FIELD_DESCRIPTION_FROM_HELP_TEXT (Default: False ) If True, GraphQL field's description will be fetched from the corresponding Django model field's help_text attribute . If a description is provided using field customization , that description will be used instead. TYPE_DESCRIPTION_FROM_MODEL_DOCSTRING (Default: False ) If True, GraphQL type descriptions will be fetched from the corresponding Django model's docstring . If a description is provided using the strawberry_django.type decorator , that description will be used instead. These features can be enabled by adding this code to your settings.py file. STRAWBERRY_DJANGO = { \"FIELD_DESCRIPTION_FROM_HELP_TEXT\" : True , \"TYPE_DESCRIPTION_FROM_MODEL_DOCSTRING\" : True , }","title":"STRAWBERRY_DJANGO"},{"location":"references/subscriptions/","text":"(TBD, not supported yet) \u00b6","title":"Subscriptions"},{"location":"references/subscriptions/#tbd-not-supported-yet","text":"","title":"(TBD, not supported yet)"},{"location":"references/types/","text":"Types \u00b6 Output types \u00b6 Output types are generated from models. The auto type is used for field type auto resolution. Relational fields are described by referencing to other types generated from Django models. A many-to-many relation is described with the typing.List type annotation. strawberry.django will automatically generate resolvers for relational fields. More information about that can be read from resolvers page. from strawberry import auto from typing import List @strawberry . django . type ( models . Fruit ) class Fruit : id : auto name : auto color : 'Color' @strawberry . django . type ( models . Color ) class Color : id : auto name : auto fruits : List [ Fruit ] Input types \u00b6 Input types can be generated from Django models using the strawberry.django.input decorator. The first parameter is the model which the type is derived from. @strawberry . django . input ( models . Fruit ) class FruitInput : id : auto name : auto color : 'ColorInput' A partial input type, in which all fields are optional, is generated by setting the partial keyword argument in input to True . Partial input types can be generated from existing input types through class inheritance. @strawberry . django . input ( models . Color , partial = True ) class FruitPartialInput ( FruitInput ): color : List [ 'ColorPartialInput' ] @strawberry . django . input ( models . Color , partial = True ) class ColorPartialInput : id : auto name : auto fruits : List [ FruitPartialInput ] Types from Django models \u00b6 Django models can be converted to strawberry Types with the strawberry_django.type decorator. Custom descriptions can be added using the description keyword argument (See: strawberry.type decorator API ). import strawberry @strawberry . django . type ( models . Fruit , description = \"A tasty snack\" ) class Fruit : ... Fields \u00b6 By default, no fields are implemented on the new type. For details on adding fields, see the Fields documentation. QuerySet setup \u00b6 By default, a strawberry_django type will get data from the default manager for its Django Model. You can implement a custom get_queryset to your type to do some extra processing to the default queryset, like filtering it further. @strawberry . django . type ( models . Fruit ) class Berry : def get_queryset ( self , queryset , info ): return queryset . filter ( name__contains = \"berry\" ) The get_queryset method is given a QuerySet to filter and a strawberry Info object containing details about the request. You can use that info parameter to, for example, limit access to results based on the current user in the request: @strawberry . django . type ( models . Fruit ) class Berry : def get_queryset ( self , queryset , info ): if not info . context . request . user . is_staff : # Restrict access to top secret berries if the user is not a staff member queryset = queryset . filter ( is_top_secret = False ) return queryset . filter ( name__contains = \"berry\" )","title":"Types"},{"location":"references/types/#types","text":"","title":"Types"},{"location":"references/types/#output-types","text":"Output types are generated from models. The auto type is used for field type auto resolution. Relational fields are described by referencing to other types generated from Django models. A many-to-many relation is described with the typing.List type annotation. strawberry.django will automatically generate resolvers for relational fields. More information about that can be read from resolvers page. from strawberry import auto from typing import List @strawberry . django . type ( models . Fruit ) class Fruit : id : auto name : auto color : 'Color' @strawberry . django . type ( models . Color ) class Color : id : auto name : auto fruits : List [ Fruit ]","title":"Output types"},{"location":"references/types/#input-types","text":"Input types can be generated from Django models using the strawberry.django.input decorator. The first parameter is the model which the type is derived from. @strawberry . django . input ( models . Fruit ) class FruitInput : id : auto name : auto color : 'ColorInput' A partial input type, in which all fields are optional, is generated by setting the partial keyword argument in input to True . Partial input types can be generated from existing input types through class inheritance. @strawberry . django . input ( models . Color , partial = True ) class FruitPartialInput ( FruitInput ): color : List [ 'ColorPartialInput' ] @strawberry . django . input ( models . Color , partial = True ) class ColorPartialInput : id : auto name : auto fruits : List [ FruitPartialInput ]","title":"Input types"},{"location":"references/types/#types-from-django-models","text":"Django models can be converted to strawberry Types with the strawberry_django.type decorator. Custom descriptions can be added using the description keyword argument (See: strawberry.type decorator API ). import strawberry @strawberry . django . type ( models . Fruit , description = \"A tasty snack\" ) class Fruit : ...","title":"Types from Django models"},{"location":"references/types/#fields","text":"By default, no fields are implemented on the new type. For details on adding fields, see the Fields documentation.","title":"Fields"},{"location":"references/types/#queryset-setup","text":"By default, a strawberry_django type will get data from the default manager for its Django Model. You can implement a custom get_queryset to your type to do some extra processing to the default queryset, like filtering it further. @strawberry . django . type ( models . Fruit ) class Berry : def get_queryset ( self , queryset , info ): return queryset . filter ( name__contains = \"berry\" ) The get_queryset method is given a QuerySet to filter and a strawberry Info object containing details about the request. You can use that info parameter to, for example, limit access to results based on the current user in the request: @strawberry . django . type ( models . Fruit ) class Berry : def get_queryset ( self , queryset , info ): if not info . context . request . user . is_staff : # Restrict access to top secret berries if the user is not a staff member queryset = queryset . filter ( is_top_secret = False ) return queryset . filter ( name__contains = \"berry\" )","title":"QuerySet setup"},{"location":"references/views/","text":"View \u00b6 from django.urls path from strawberry.django.views import GraphQLView , AsyncGraphQLView from .schema import schema urlpatterns = [ path ( 'graphql/sync' , GraphQLView . as_view ( schema = schema )), path ( 'graphql' , AsyncGraphQLView . as_view ( schema = schema )), ]","title":"Views"},{"location":"references/views/#view","text":"from django.urls path from strawberry.django.views import GraphQLView , AsyncGraphQLView from .schema import schema urlpatterns = [ path ( 'graphql/sync' , GraphQLView . as_view ( schema = schema )), path ( 'graphql' , AsyncGraphQLView . as_view ( schema = schema )), ]","title":"View"}]}